/*std::array — це фіксований масив, який не конвертується у вказівник при передачі в функцію як параметр.
std::array визначається в заголовковому файлі array, всередині простору імен std.*/
#include <array>
#include <algorithm>
#include <iostream>
#include <windows.h>
void printLength(const std::array<int, 14> & myarray)
{
    std::cout << "Розмір масива: " << myarray.size() << std::endl;
}
int main()
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);
    std::array<int, 14> myarray; // оголошуємо масив елементів типу int довжиною 14
    /*
    Подібно звичайним фіксованим масивам, довжина std::array має бути встановлена під час компіляції.
    std::array можна ініціалізувати за допомогою списку ініціалізаторів або уніфікованої ініціалізації:
    */
    std::array<int, 14> myarray1 = { 8, 6, 4, 1 };   // список ініціалізаторів
    std::array<int, 14> myarray2   { 8, 6, 4, 1 };   // uniform-ініціалізація
    //На відміну від стандартних фіксованих масивів, в std::array ви не можете пропустити(не вказувати) довжину масиву.
    //Також можна присвоювати значення існуючого масиву за допомогою списку ініціалізаторів :
    myarray = { 8, 6 }; // іншим елементам присвоєно нуль!
    myarray = { 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 10, 11, 12, 13 }; // ок

    //myarray = { 0, 1, 3, 5, 7, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 }; 
    // заборонено, занадто багато елементів в списку ініціалізаторів!
    //Доступ до значень масиву через оператор індексу здійснюється як зазвичай :
    myarray[12] = 720;
    std::cout <<"Нове значення елемента масива: "<< myarray[12];
    std::cout << std::endl;
    myarray[2] = 7;
    /*
    Так само, як і в стандартних фіксованих масивах, оператор індексу, тобто [] не виконує ніяких перевірок на діапазон.
    Якщо вказано некоректний індекс, то неявно відбудуться погані речі.
    Але std::array підтримує ще одну форму доступу до елементів масиву — функція at(), яка здійснює перевірку діапазону :
    */
    myarray.at(1) = 720; // елемент масиву під номером 1 - коректний, присвоюємо йому значення
    //myarray.at(18) = 150; // елемент масиву під номером 8 - некоректний, отримаємо помилку
    /*
    У прикладі, наведеному вище, виклик myarray.at(1) перевіряє, чи є елемент масиву під номером 1, і, оскільки він є, 
    то є можливість змінити його. І ми присвоюємо йому значення 720. Проте, виклик myarray.at(18) не спрацьовує, оскільки елементу 
    під номером 8 у масиві нема. Функція at() видає помилку, яка завершує роботу програми (генерується виняток типу std::out_of_range.
    Про винятки ми поговоримо трішки пізніше). Оскільки перевірка діапазону виконується, то функція at() працює повільніше(але безпечніше), 
    ніж оператор[].
    */
    //За допомогою функції size() можна дізнатися довжину масиву :
    std::cout << "Розмір масива: " << myarray.size() << std::endl;
    /*
    Функція size() працюватиме, навіть якщо її викликати з іншої функції :
    */
    printLength(myarray);
    /*
    Зверніть увагу, Cтандартна бібліотека C++ використовує термін «розмір» для позначення довжини масиву — не плутайте це з результатами 
    виконання оператора sizeof зі звичайним фіксованим масивом, коли повертається фактичний розмір масиву в пам’яті 
    (розмір_елементу * довжина_масиву).
    Також зверніть увагу на те, що ми передаємо std::array по (константному) посиланню (&).Це робиться для того, 
    щоб компілятор не виконував копіювання масиву при передачі в функцію.
    Правило : передавайте std::array в функцію по звичайному або константному посиланню.
    */


    // Оскільки довжина масиву завжди відома, то цикли foreach також можна використовувати з std::array :

    for (auto& element : myarray)
    {
        std::cout << element << ' ';
    }
    std::cout << std::endl;
    //Ви можете відсортувати std::array, використовуючи функцію std::sort(), яка є в заголовку algorithm :
    std::sort(myarray.begin(), myarray.end());   // сортування масиву за зростанням
    for (const auto& element : myarray)
    {
        std::cout << element << ' ';
    }
    std::cout << std::endl;
    std::sort(myarray.rbegin(), myarray.rend()); // сортування масиву за спаданням
    for (const auto& element : myarray)
    {
        std::cout << element << ' ';
    }
    std::cout << std::endl;
    return 0;
}

//Функція сортування використовує ітератори, які ми ще не розглядали.Про них ми поговоримо на відповідному уроці.

/*
Висновки
std::array — це чудова заміна стандартним фіксованим масивам.
Масиви, створені за допомогою std::array, ефективніші, використовують менше пам’яті. Єдиним недоліком std::array в порівнянні 
зі стандартними фіксованими масивами є те, що потрібно явно вказувати довжину масиву (компілятор не обчислюватиме її за нас).
Але це порівняно незначні нюанси.Рекомендується використовувати std::array замість стандартних фіксованих масивів в будь-яких 
нетривіальних завданнях.
*/